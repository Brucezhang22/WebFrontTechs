<!-- 
	/*
		doctype
		# means document type
		# doctype for html5 is <!DOCTYPE html>
		# to distinguish between a standard-compliant parsing mode and a quirks pasring mode
	*/

	/*
		full standards mode, almost standards mode quirks mode
		# quirks mode: 兼容模式，以IE5和网景4的渲染方式渲染页面，用来兼容比较老的网页
		# full standards mode: 按照通用的标准来渲染页面
		# almost standards mode: inline boxes that have no non-whitespace text as a child and have no border, padding, or margin
	*/

	/*
		html and xhtml
		# xhtml语法更严格
		# xhtml的element和attribute区分大小写
		# xhtml非标签处不能存在 "<" 和 "&"
		# 语法错误会导致xhtml parse失败
	*/
	
	/*
		text/html and application/xhtml+xml
		# text/html 以html的标准去解析
		# application/xhtml+xml 以xhtml的标准解析
		# application/xhtml+xml时，如果返回的文档格式不是标准的xml，页面报错
		# IE8无法解析application/xhtml+xml，会以文件的形式被下载，IE9才开始支持
	*/

	/*
		serve a page in multiple languages
		# 在请求的时候把需要显示的语言放在Accept-Language的头或者url parameterlim
		# 返回的html里面也需要声明网页的语言：<html lang="en">...</html>
	*/

	/*
		实现网站多语言支持的注意点
		# <html lang="en">...</html>
		# 提供给用户选择语言的入口，并可根据用户选择返回对应语言的网页
		# 图片中尽量不要包含文字，或者为每种语言制作相应版本的图片
		# 注意文字的长度不要引起样式的混乱，在中文中很短的文字在其它语言里面可能会变的很长
		# 不同国家和地区对颜色的理解可能不一样，要注意选择合适的颜色
		# 不同国家和地区习惯书写的日期格式可能不同，注意适配
		# 货币的符号
		# 注意不同语言之间翻译的准确性
		# 注意阅读习惯的不同，比如传统中文／日语里面是从右到左开始读
	*/
	
	/*
		data-的作用
		# 存放用户自定义的数据
		# 现在用的比较少了，各种框架的流行导致用户数据更多的被定义和存放在js模型里面
		# 缺点：用户可以在浏览器里面随意修改
	*/

	/*
		html5的先进性:(https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5)
		# semantics: 语义性得到增强，增加了语义性比较好的元素：section, article, nav, header, footer, aside等
		# connectivity: 增加了web socket, server-sent events, WebRTC
		# offline && storage: 增加online, offline事件；增加sessionStorage和localStorage；增加FileReader
		# multimedia: 增加audio, video标签；增加WebRTC；增加camera api；增加Track and WebVTT
		# 3D graphics and effects: 增加canvas、text api for canvas、WebGL、SVG
		# performance and integration: 增加web worker、XMLHttpRequest level2、JIT-compiling JavaScript engines、new History API、The contentEditable Attribute、Drag and drop、Focus management in HTML、Web-based protocol handlers、requestAnimationFrame、Fullscreen API、Pointer Lock API、Online and offline events
		# device access: camera api, touch event, geolocation api, device orientation api, pointer locker api
		# styling: new background styling features, more fancy borders, animating your style, typography improvement, new presentational layouts
	*/

	/*
		cookie, sessionStorate, localStorage
		# 客户端、服务端都能创建cookie，ss和ls只能由客户端创建
		# cookie的过期时间为手动设置（不设置的话默认为sessionCookie），ss为会话结束后就被删除，ls为永久有效
		# cookie属于某个域名，ls和ss不属于
		# cookie会被放在请求的头部发送给服务端，ls和ss不会
		# cookie最大为4kb，ls和ss最大为容量各种浏览器不一样，5MB～25MB都有
		# 所有的窗口都能访问cookie和ls，而ss只有特定窗口能访问
	*/

	/*
		why put css in <head> and js in the end of <body>?
		(https://developer.yahoo.com/performance/rules.html#css_top)
		# html规范明确表示
		# 把css放在head中可以实现渐进加载，视觉效果上网页加载更快
		# 如果把css放在body最后，部分浏览器有避免重复渲染页面的机制，所以会等css加载完了再渲染页面，导致开始只能看到空白页面，而没有渐进加载的效果。就算没有这种机制，在css加载完成之前用户会看到错乱的页面
		# js会阻塞其它所有的并行下载进程，导致页面加载变慢
	*/

	/*
		<script>, <script async> and <script defer>
		# <script>: 其它文件的下载和html解析都会被阻塞，知道js加载并执行完成后才会继续
		# <script async>: 不会阻塞其它下载进程和html解析，适合用于不依赖其它js的js
		# <script defer>: 不会阻塞其它下载进程和html解析，而且会等到html解析完成后再执行，效果等同于把js放到body的最后面，但是部分浏览器不支持defer，所以最好的方法还是把js放到body最后面
	*/

	/*
		progressive rendering
		# 图片的延迟加载
		# 用ajax在页面加载完成之后再加载额外的信息
	*/

 -->



<!DOCTYPE html>
<html>
<head>
	<title></title>
	<style>
		.container{
			overflow: auto;	
		}
		.box1{
			width: 200px;
			height: 100px;
			background-color: #ff2222;
			/*float: left;*/
		}
		.box2{
			width: 100px;
			height: 100px;
			background-color: #22ff22;
			float: right;
		}
		.clearfix:after{
			content: " ";
			visibility: hidden;
			display: block;;
			height: 0;
			clear: both;
		}
		.page-break{
			display: none;;
			page-break-before: always;
		}
	</style>
</head>
<body>
	<div id="log"></div>

	<script src="main.js"></script>
</body>
</html>